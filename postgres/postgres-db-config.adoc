---
sidebar: sidebar 
permalink: postgres/postgres-db-config.html 
keywords: PostgreSQL,database,postgres 
summary: 使用ONTAP的PostgreSQL数据库配置 
---
= 使用ONTAP的PostgreSQL数据库配置
:allow-uri-read: 
:icons: font
:imagesdir: ../media/


[role="lead"]
可以通过多种PostgreSQL调整配置来提高性能。

最常用的参数如下：

* `max_connections = <num>`：一次可建立的最大数据库连接数。使用此参数可限制磁盘交换并导致性能下降。根据您的应用程序要求、您还可以针对连接池设置调整此参数。
* `shared_buffers = <num>`：提高数据库服务器性能的最简单方法。对于大多数现代硬件、默认值为low。在部署期间、它会设置为系统上可用RAM的大约25%。此参数设置因其在特定数据库实例中的工作方式而异；您可能需要按试用和错误增加和减小值。但是、将其设置为高可能会降低性能。
* `effective_cache_size = <num>`:该值告诉PostgreSQL的优化器PostgreSQL有多少内存可用于缓存数据，并帮助确定是否使用索引。值越大、使用索引的可能性就越大。此参数应设置为分配给的内存量 `shared_buffers` 加上可用的操作系统缓存容量。此值通常超过系统总内存的50%。
* `work_mem = <num>`:该参数控制在排序操作和哈希表中使用的内存量。如果您在应用程序中进行大量排序，则可能需要增加内存量，但要小心。它不是系统范围的参数、而是每个操作的参数。如果复杂查询包含多个排序操作、则它会使用多个work _mEM单元内存、多个后端可以同时执行此操作。如果值过大、此查询通常会导致数据库服务器进行交换。此选项以前在早期版本的PostgreSQL中称为Sort_mm。
* `fsync = <boolean> (on or off)`:此参数用于确定在提交事务之前是否应使用fsync()将所有WAL页面同步到磁盘。关闭它有时可以提高写入性能、而打开它可以增强保护、防止在系统崩溃时发生损坏。
* `checkpoint_timeout`：检查点进程将已提交的数据转至磁盘。这涉及到磁盘上的大量读/写操作。该值以秒为单位进行设置、较低的值可缩短崩溃恢复时间、增加该值可通过减少检查点调用来减少系统资源的负载。根据应用程序的严重程度、使用情况和数据库可用性、设置checkpoint_timeout的值。
* `commit_delay = <num>` 和 `commit_siblings = <num>`：这些选项结合使用，可以同时写出多个提交的事务，从而帮助提高性能。如果在提交事务时有多个commit兄弟姐妹对象处于活动状态、则服务器将等待commit delay微秒尝试一次提交多个事务。
* `max_worker_processes / max_parallel_workers`：为流程配置最佳数量的员工。max_paral_workers对应于可用的CPU数量。根据应用程序设计、查询可能需要较少的工作人员来执行并行操作。最好保持两个参数的值相同、但在测试后调整该值。
* `random_page_cost = <num>`：该值控制PostgreSQL查看非顺序磁盘读取的方式。值越高、意味着PostgreSQL更有可能使用顺序扫描而不是索引扫描、这表示您的服务器具有快速磁盘在评估基于计划的优化、清理、索引以更改查询或架构等其他选项后修改此设置。
* `effective_io_concurrency = <num>`：此参数用于设置PostgreSQL尝试同时执行的并发磁盘I/O操作的数量。提高此值会增加任何单个PostgreSQL会话尝试并行启动的I/O操作的数量。允许的范围为1到1、000或零、用于禁止发出异步I/O请求。目前、此设置仅影响位图堆扫描。固态驱动器(SSD)和其他基于内存的存储(NVMe)通常可以处理多个并发请求、因此、数百个请求的最大价值可能是。


有关PostgreSQL配置参数的完整列表、请参见PostgreSQL文档。



== 吐司

TOAST表示超大属性存储技术。PostgreSQL使用固定的页面大小(通常为8 KB)、并且不允许元组跨越多个页面。因此、无法直接存储大字段值。当您尝试存储超过此大小的行时、TOAST会将大型列的数据拆分成较小的"部分"、并将其存储在TOAST表中。

只有在将结果集发送到客户端时、才会提取已分配属性的大值(如果已选中)。表本身要小得多、并且可以在共享缓冲区缓存中容纳更多行、而不是在没有任何线外存储(TOAST)的情况下。



== 真空

在正常的PostgreSQL操作中，被更新删除或废弃的元组不会从其表中物理删除；它们会一直存在，直到运行真空为止。因此、您必须定期运行真空、尤其是在频繁更新的表上。然后、必须回收占用的空间、供新行重复使用、以避免磁盘空间中断。但是、它不会将空间归还给操作系统。

页面中的可用空间不会碎片化。真空会重新写入整个数据块、从而高效地填充其余行、并在一页中保留一个连续的可用空间块。

相比之下、真空全满会通过写入不含死空间的全新表文件来主动压缩表。此操作可最大程度地减小表大小、但可能需要很长时间。此外、还需要额外的磁盘空间来创建新的表副本、直到操作完成为止。常规真空的目标是避免真空完全发挥作用。此过程不仅可以将表保持在其最小大小、还可以保持磁盘空间的稳定使用状态。
